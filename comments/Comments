
WATCH YOUR BACK, PART B - COMMENTS


"""
Project Plan Submission for Watch Your Back (part B)
COMP30024 Artificial Intelligence 2018 Semester 1

Marie-Laurence Godinot <mgodinot@student.unimelb.edu.au>
Jason Sean Pursey <jpursey@student.unimelb.edu.au>
"""





------------------------------
 GUIDE OF OUR DIFFERENT FILES:
------------------------------






--------------------------------------
 DESCRIPTION OF OUR MODULES / CLASSES:
--------------------------------------

 We have decided to create the following classes: 
 - player
 - state
 - move
 - Watchyourback


# PLAYER

 The class "player" has 3 methods:
 - _init_ (colour:string): 
 - action (turns:int)
 - update (action:tuple): it is called by the referee program to inform our 
 player about the opponentâ€™s most recent move, so we do update our board 
 configuration.



# STATE

 The class "state" has 2 methods:
 - generate: 



# MOVE

 The class "move" has 3 properties:
 - action: this tuple of tuples tells us which piece is being moved. For 
 instance, ((a,b),(c,d)) would mean that the piece currently in the (a,b) 
 position is being moved to the (c,d) position. 
 - player: this string corresponds to either 'black' or 'white'. It tells us who 
 is playing the move. 
 - type: this string corresponds to either 'move' or 'place'. This helps us know 
 whether we are in the placement or moving phase. 



# WATCHYOURBACK

We wanted to use the AIMA code for our minimax player: to do so, we have had to
implement a class entitled "Watchyourback" that would fit the template class of 
the AIMA code.

We have had to implement additional methods in the class "Watchyourback":
- _init_(self)
- compute_utility(board, turns_taken).





---------------------------------
REPRESENTING THE SHRINKING BOARD:
---------------------------------

In order not to get confused by the number of the rows and columns after the 
shrinking of the board, we have decided to use hyphens to represent the columns 
and the rows which no longer exist. 
Consequently, the number of the columns and the rows keep their original names 
without having to care about it. 
We have created two functions for the two shrinking cases. These functions:
1. Update the edges
2. Update the corners
3. Check if pieces are being eliminated because of the post-shrinking 
configuration.





----------------------------
OUR APPROACH OF THE PROBLEM:
----------------------------

Step 1:

Our first step was to implement a player that just takes random legal actions. 
We tested this player by having him play against himself and it worked. We have 
then decided to head on to step 2. 



Step 2:

After having implemented a basic "non-intelligent" player, we wanted to create a
more intelligent agent. This meant using one of the search techniques discussed
in lectures. 
We have decided to focus on Minimax. Before doing this, we knew that this 
algorithm would get tricky because of the great number of game states (it needs 
to search all the leaves of the tree, which increase exponentially to its depth)
We knew that we would have to focus on alpha-beta pruning at some point.

We have used the online supporting material for topics covered in Chapter 5 - 
Adversarial Search in the book Artificial Intelligence: A Modern Approach. 

To use the alpha-beta AIMA player, we needed to create a Watchyourback class 
that would respect the frame required by the class "Game" of their module. 
After having done this, we have implemented our minimax player with the 
following utility function: returning 1 for a winning state for white, -1 for a
winning state for black and returning 0 in other cases. 


However, when testing it, we would only get the following message:
"maximum recursion depth reached". As we had presumed, the search space was too 
big for our algorithm to work properly. 



Step 3:

As Minimax alone wouldn't work because of its enormous search space, we have 
then decided to deal with mimimax combined with alpha-beta pruning.

This time, our player worked when testing it. 





-----------------------
TESTING OUR ALGORITHMS:
-----------------------

We have come up with two ways of testing our algorithm:
1. we have had our algorithm play against itself;
2. and we have created a human player (humanplayer.py) so that we can play 
ourselves against our implemented players.

